pipeline {
    agent any

    environment {
        AWS_REGION = 'ap-northeast-2'
        AWS_ACCOUNT_ID = '490913547024'
        DOCKER_REGISTRY = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

        // Git 정보
        GIT_COMMIT_SHORT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()

        // Jenkins에서 AWS 자격증명을 위한 credential ID (Jenkins에서 설정 필요)
        AWS_CREDENTIALS = 'aws-ecr-credentials'
    }

    parameters {
        choice(
            name: 'TARGET_BRANCH',
            choices: ['release/1.0.0', 'main', 'develop'],
            description: '빌드할 브랜치 선택'
        )
        booleanParam(
            name: 'FORCE_BUILD_ALL',
            defaultValue: false,
            description: '모든 모듈 강제 빌드 여부'
        )
    }

    stages {
        stage('Check Tools') {
            steps {
                script {
                    echo "Checking available tools..."
                    
                    // 사용 가능한 도구들 확인
                    sh '''
                        echo "=== System Information ==="
                        whoami
                        pwd
                        echo "========================"
                        
                        echo "=== Available Tools ==="
                        echo "Java:"
                        java -version || echo "Java not found"
                        
                        echo "Docker:"
                        docker --version || echo "Docker not found"
                        
                        echo "AWS CLI:"
                        aws --version || echo "AWS CLI not found"
                        
                        echo "Git:"
                        git --version || echo "Git not found"
                        
                        echo "Curl:"
                        curl --version || echo "Curl not found"
                        echo "========================"
                    '''
                    
                    // Docker 사용 가능 여부 확인
                    def dockerAvailable = sh(script: 'command -v docker', returnStatus: true) == 0
                    env.DOCKER_AVAILABLE = dockerAvailable.toString()
                    
                    // AWS CLI 사용 가능 여부 확인
                    def awsAvailable = sh(script: 'command -v aws', returnStatus: true) == 0
                    env.AWS_AVAILABLE = awsAvailable.toString()
                    
                    echo "Docker available: ${dockerAvailable}"
                    echo "AWS CLI available: ${awsAvailable}"
                    
                    // 필수 도구가 없는 경우 경고
                    if (!dockerAvailable) {
                        echo "⚠️ Docker is not available. Please install Docker or use Docker-in-Docker setup."
                    }
                    if (!awsAvailable) {
                        echo "⚠️ AWS CLI is not available. Please install AWS CLI or add it to the Jenkins image."
                    }
                }
            }
        }

        stage('Checkout') {
            steps {
                checkout scm
                script {
                    // 변경된 파일들 확인
                    def changedFiles = sh(
                        script: "git diff --name-only HEAD~1 HEAD || git ls-files",
                        returnStdout: true
                    ).trim().split('\n')

                    echo "Changed files: ${changedFiles}"
                    env.CHANGED_FILES = changedFiles.join(' ')
                }
            }
        }

        stage('Determine Changed Modules') {
            steps {
                script {
                    // 모듈 정보 정의 (GitHub Actions workflow 기반)
                    def modules = [
                        'auth': [
                            'path': 'msa-auth-service',
                            'ecrRepo': 'auth-service',
                            'containerName': 'auth-service'
                        ],
                        'common': [
                            'path': 'msa-common-service',
                            'ecrRepo': 'common-service',
                            'containerName': 'msa-common-service'
                        ],
                        'order': [
                            'path': 'msa-order-service',
                            'ecrRepo': 'order-service',
                            'containerName': 'msa-order-service'
                        ],
                        'payment': [
                            'path': 'msa-payment-service',
                            'ecrRepo': 'payment-service',
                            'containerName': 'msa-payment-service'
                        ],
                        'store': [
                            'path': 'msa-store-service',
                            'ecrRepo': 'store-service',
                            'containerName': 'msa-store-service'
                        ],
                        'user': [
                            'path': 'msa-user-service',
                            'ecrRepo': 'user-service',
                            'containerName': 'msa-user-service'
                        ]
                    ]

                    def changedModules = []
                    def changedFiles = env.CHANGED_FILES.split(' ')

                    if (params.FORCE_BUILD_ALL) {
                        changedModules = modules.keySet().toList()
                        echo "Force build all modules enabled"
                    } else {
                        modules.each { moduleName, moduleInfo ->
                            def hasChanges = changedFiles.any { file ->
                                file.startsWith(moduleInfo.path + '/')
                            }
                            if (hasChanges) {
                                changedModules.add(moduleName)
                            }
                        }
                    }

                    env.CHANGED_MODULES = changedModules.join(',')
                    env.MODULES_JSON = writeJSON returnText: true, json: modules

                    echo "Changed modules: ${changedModules}"

                    if (changedModules.isEmpty()) {
                        echo "No modules changed. Skipping build."
                        currentBuild.result = 'SUCCESS'
                        return
                    }
                }
            }
        }
        
        stage('Build Only (Without Docker)') {
            when {
                allOf {
                    not { environment name: 'CHANGED_MODULES', value: '' }
                    anyOf {
                        environment name: 'DOCKER_AVAILABLE', value: 'false'
                        environment name: 'AWS_AVAILABLE', value: 'false'
                    }
                }
            }
            steps {
                script {
                    def modules = readJSON text: env.MODULES_JSON
                    def changedModules = env.CHANGED_MODULES.split(',')
                    
                    echo "⚠️ Docker or AWS CLI not available. Building without Docker deployment."
                    
                    changedModules.each { moduleName ->
                        def moduleInfo = modules[moduleName]
                        def servicePath = moduleInfo.path
                        
                        stage("Build ${moduleName} (Gradle Only)") {
                            echo "Building module: ${moduleName} (Gradle only)"
                            
                            // Gradle 빌드만 수행
                            sh """
                                echo "Building ${servicePath}..."
                                chmod +x ./gradlew || echo "gradlew not found, using system gradle"
                                ./gradlew :${servicePath}:build --no-daemon --stacktrace || gradle :${servicePath}:build --no-daemon --stacktrace
                            """
                            
                            echo "Module ${moduleName} Gradle build completed!"
                        }
                    }
                }
            }
        }
        
        stage('Install Docker & AWS CLI') {
            when {
                allOf {
                    not { environment name: 'CHANGED_MODULES', value: '' }
                    anyOf {
                        environment name: 'DOCKER_AVAILABLE', value: 'false'
                        environment name: 'AWS_AVAILABLE', value: 'false'
                    }
                }
            }
            steps {
                script {
                    echo "🔧 Installing missing tools..."
                    
                    // Docker 설치 (root 권한이 있는 경우)
                    if (env.DOCKER_AVAILABLE == 'false') {
                        sh '''
                            # Docker 설치 시도
                            apt-get update || echo "Cannot update packages"
                            apt-get install -y docker.io || echo "Cannot install docker.io"
                            
                            # Docker 서비스 시작 시도
                            service docker start || systemctl start docker || echo "Cannot start docker service"
                            
                            # Docker 버전 확인
                            docker --version || echo "Docker still not available"
                        '''
                    }
                    
                    // AWS CLI 설치 (바이너리 다운로드 방식)
                    if (env.AWS_AVAILABLE == 'false') {
                        sh '''
                            # AWS CLI 바이너리 직접 다운로드 및 설치
                            cd /tmp
                            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip" || echo "Failed to download AWS CLI"
                            unzip -o awscliv2.zip || echo "Failed to unzip AWS CLI"
                            
                            # 임시 디렉토리에 설치
                            mkdir -p /tmp/aws-cli
                            cp -r aws/* /tmp/aws-cli/ || echo "Failed to copy AWS CLI"
                            
                            # PATH에 추가할 수 있도록 심볼릭 링크 생성 시도
                            ln -sf /tmp/aws-cli/dist/aws /usr/local/bin/aws || echo "Cannot create symlink, will use full path"
                            
                            # AWS CLI 버전 확인
                            /tmp/aws-cli/dist/aws --version || aws --version || echo "AWS CLI still not available"
                            
                            # 정리
                            rm -rf awscliv2.zip aws/ || echo "Cleanup failed"
                        '''
                    }
                }
            }
        }
        
        stage('Build and Deploy Changed Modules') {
            when {
                not { environment name: 'CHANGED_MODULES', value: '' }
            }
            steps {
                script {
                    def modules = readJSON text: env.MODULES_JSON
                    def changedModules = env.CHANGED_MODULES.split(',')

                    // AWS 자격증명 및 ECR 로그인
                    withCredentials([
                        [
                            $class: 'AmazonWebServicesCredentialsBinding',
                            credentialsId: env.AWS_CREDENTIALS,
                            accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                            secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                        ]
                    ]) {
                        sh """
                            # AWS CLI 경로 설정
                            export AWS_CLI_PATH=\$(which aws || echo "/tmp/aws-cli/dist/aws")
                            echo "Using AWS CLI at: \$AWS_CLI_PATH"
                            
                            \$AWS_CLI_PATH configure set aws_access_key_id \$AWS_ACCESS_KEY_ID
                            \$AWS_CLI_PATH configure set aws_secret_access_key \$AWS_SECRET_ACCESS_KEY
                            \$AWS_CLI_PATH configure set default.region ${env.AWS_REGION}
                            
                            # ECR 로그인
                            \$AWS_CLI_PATH ecr get-login-password --region ${env.AWS_REGION} | \
                            docker login --username AWS --password-stdin ${env.DOCKER_REGISTRY}
                        """
                    }

                    // 각 변경된 모듈에 대해 순차 실행 (리소스 절약)
                    changedModules.each { moduleName ->
                        def moduleInfo = modules[moduleName]
                        def servicePath = moduleInfo.path
                        def ecrRepo = moduleInfo.ecrRepo
                        def containerName = moduleInfo.containerName

                        stage("Build ${moduleName}") {
                            echo "Building module: ${moduleName}"

                            // Gradle 빌드
                            sh """
                                echo "Building ${servicePath}..."
                                chmod +x ./gradlew
                                ./gradlew :${servicePath}:build --no-daemon --stacktrace
                            """

                            // Docker 빌드 및 푸시
                            def imageTag = "${env.DOCKER_REGISTRY}/${ecrRepo}:${env.GIT_COMMIT_SHORT}"
                            def latestTag = "${env.DOCKER_REGISTRY}/${ecrRepo}:latest"

                            sh """
                                echo "Building Docker image: ${imageTag}"

                                # Docker 빌드 및 푸시
                                docker build --platform linux/amd64 \
                                    -t ${imageTag} \
                                    -t ${latestTag} \
                                    -f ./${servicePath}/Dockerfile .

                                docker push ${imageTag}
                                docker push ${latestTag}

                                echo "Successfully pushed: ${imageTag}"
                            """

                            // 배포 단계 (EKS - 필요시 주석 해제)
                            /*
                            sh """
                                echo "Deploying to Kubernetes..."
                                aws eks update-kubeconfig --name Groom-EKS-Cluster --region ${env.AWS_REGION}
                                kubectl set image deployment/${containerName} \
                                    ${containerName}=${imageTag} -n default
                                kubectl rollout status deployment/${containerName} -n default
                            """
                            */

                            echo "Module ${moduleName} build completed successfully!"
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            // Docker 이미지 정리
            sh '''
                echo "Cleaning up Docker images..."
                docker system prune -f || true
                docker image prune -f || true
            '''
        }
        success {
            echo "🎉 Pipeline completed successfully!"
            script {
                if (env.CHANGED_MODULES) {
                    def modules = env.CHANGED_MODULES.split(',')
                    echo "✅ Successfully built and deployed modules: ${modules.join(', ')}"

                    // 빌드된 이미지 정보 출력
                    modules.each { module ->
                        echo "📦 ${module}: ${env.DOCKER_REGISTRY}/${module}-service:${env.GIT_COMMIT_SHORT}"
                    }
                } else {
                    echo "ℹ️ No changes detected, pipeline completed without build."
                }
            }
        }
        failure {
            echo "❌ Pipeline failed!"
            echo "Please check the logs for detailed error information."
        }
    }

    triggers {
        // GitHub webhook 트리거
        githubPush()

        // 또는 SCM 폴링 (5분마다 체크) - 선택사항
        // pollSCM('H/5 * * * *')
    }
}
