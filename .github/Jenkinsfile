pipeline {
    agent any

    environment {
        AWS_REGION = 'ap-northeast-2'
        AWS_ACCOUNT_ID = '490913547024'
        DOCKER_REGISTRY = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

        // Git ì •ë³´
        GIT_COMMIT_SHORT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()

        // Jenkinsì—ì„œ AWS ìê²©ì¦ëª…ì„ ìœ„í•œ credential ID (Jenkinsì—ì„œ ì„¤ì • í•„ìš”)
        AWS_CREDENTIALS = 'aws-ecr-credentials'
    }

    parameters {
        choice(
            name: 'TARGET_BRANCH',
            choices: ['release/1.0.0', 'main', 'develop'],
            description: 'ë¹Œë“œí•  ë¸Œëœì¹˜ ì„ íƒ'
        )
        booleanParam(
            name: 'FORCE_BUILD_ALL',
            defaultValue: false,
            description: 'ëª¨ë“  ëª¨ë“ˆ ê°•ì œ ë¹Œë“œ ì—¬ë¶€'
        )
        booleanParam(
            name: 'INSTALL_TOOLS',
            defaultValue: true,
            description: 'Docker, AWS CLI ì„¤ì¹˜ ì—¬ë¶€'
        )
    }

    stages {
        stage('Setup Tools') {
            when {
                params('INSTALL_TOOLS')
            }
            steps {
                script {
                    echo "Setting up Docker and AWS CLI..."

                    // Docker ì„¤ì¹˜ í™•ì¸ ë° ì„¤ì¹˜
                    def dockerExists = sh(script: 'command -v docker', returnStatus: true) == 0
                    if (!dockerExists) {
                        echo "Installing Docker..."
                        sh '''
                            # Docker ì„¤ì¹˜ (Ubuntu/Debian ê¸°ì¤€)
                            sudo apt-get update -y
                            sudo apt-get install -y apt-transport-https ca-certificates curl gnupg lsb-release

                            # Docker GPG í‚¤ ì¶”ê°€
                            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

                            # Docker ë¦¬í¬ì§€í† ë¦¬ ì¶”ê°€
                            echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

                            # Docker ì„¤ì¹˜
                            sudo apt-get update -y
                            sudo apt-get install -y docker-ce docker-ce-cli containerd.io

                            # Jenkins ì‚¬ìš©ìë¥¼ docker ê·¸ë£¹ì— ì¶”ê°€
                            sudo usermod -aG docker jenkins

                            # Docker ì„œë¹„ìŠ¤ ì‹œì‘
                            sudo systemctl start docker
                            sudo systemctl enable docker
                        '''
                    } else {
                        echo "Docker already installed"
                    }

                    // AWS CLI ì„¤ì¹˜ í™•ì¸ ë° ì„¤ì¹˜
                    def awsCliExists = sh(script: 'command -v aws', returnStatus: true) == 0
                    if (!awsCliExists) {
                        echo "Installing AWS CLI..."
                        sh '''
                            # AWS CLI v2 ì„¤ì¹˜
                            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                            unzip -q awscliv2.zip
                            sudo ./aws/install
                            rm -rf awscliv2.zip aws/
                        '''
                    } else {
                        echo "AWS CLI already installed"
                    }

                    // ë²„ì „ í™•ì¸
                    sh '''
                        echo "=== Installed Tool Versions ==="
                        docker --version
                        aws --version
                        echo "=============================="
                    '''
                }
            }
        }

        stage('Checkout') {
            steps {
                checkout scm
                script {
                    // ë³€ê²½ëœ íŒŒì¼ë“¤ í™•ì¸
                    def changedFiles = sh(
                        script: "git diff --name-only HEAD~1 HEAD || git ls-files",
                        returnStdout: true
                    ).trim().split('\n')

                    echo "Changed files: ${changedFiles}"
                    env.CHANGED_FILES = changedFiles.join(' ')
                }
            }
        }

        stage('Determine Changed Modules') {
            steps {
                script {
                    // ëª¨ë“ˆ ì •ë³´ ì •ì˜ (GitHub Actions workflow ê¸°ë°˜)
                    def modules = [
                        'auth': [
                            'path': 'msa-auth-service',
                            'ecrRepo': 'auth-service',
                            'containerName': 'auth-service'
                        ],
                        'common': [
                            'path': 'msa-common-service',
                            'ecrRepo': 'common-service',
                            'containerName': 'msa-common-service'
                        ],
                        'order': [
                            'path': 'msa-order-service',
                            'ecrRepo': 'order-service',
                            'containerName': 'msa-order-service'
                        ],
                        'payment': [
                            'path': 'msa-payment-service',
                            'ecrRepo': 'payment-service',
                            'containerName': 'msa-payment-service'
                        ],
                        'store': [
                            'path': 'msa-store-service',
                            'ecrRepo': 'store-service',
                            'containerName': 'msa-store-service'
                        ],
                        'user': [
                            'path': 'msa-user-service',
                            'ecrRepo': 'user-service',
                            'containerName': 'msa-user-service'
                        ]
                    ]

                    def changedModules = []
                    def changedFiles = env.CHANGED_FILES.split(' ')

                    if (params.FORCE_BUILD_ALL) {
                        changedModules = modules.keySet().toList()
                        echo "Force build all modules enabled"
                    } else {
                        modules.each { moduleName, moduleInfo ->
                            def hasChanges = changedFiles.any { file ->
                                file.startsWith(moduleInfo.path + '/')
                            }
                            if (hasChanges) {
                                changedModules.add(moduleName)
                            }
                        }
                    }

                    env.CHANGED_MODULES = changedModules.join(',')
                    env.MODULES_JSON = writeJSON returnText: true, json: modules

                    echo "Changed modules: ${changedModules}"

                    if (changedModules.isEmpty()) {
                        echo "No modules changed. Skipping build."
                        currentBuild.result = 'SUCCESS'
                        return
                    }
                }
            }
        }

        stage('Build and Deploy Changed Modules') {
            when {
                not {
                    environment name: 'CHANGED_MODULES', value: ''
                }
            }
            steps {
                script {
                    def modules = readJSON text: env.MODULES_JSON
                    def changedModules = env.CHANGED_MODULES.split(',')

                    // AWS ìê²©ì¦ëª… ë° ECR ë¡œê·¸ì¸
                    withCredentials([
                        [
                            $class: 'AmazonWebServicesCredentialsBinding',
                            credentialsId: env.AWS_CREDENTIALS,
                            accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                            secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                        ]
                    ]) {
                        sh """
                            aws configure set aws_access_key_id \$AWS_ACCESS_KEY_ID
                            aws configure set aws_secret_access_key \$AWS_SECRET_ACCESS_KEY
                            aws configure set default.region ${env.AWS_REGION}

                            # ECR ë¡œê·¸ì¸
                            aws ecr get-login-password --region ${env.AWS_REGION} | \
                            docker login --username AWS --password-stdin ${env.DOCKER_REGISTRY}
                        """
                    }

                    // ê° ë³€ê²½ëœ ëª¨ë“ˆì— ëŒ€í•´ ìˆœì°¨ ì‹¤í–‰ (ë¦¬ì†ŒìŠ¤ ì ˆì•½)
                    changedModules.each { moduleName ->
                        def moduleInfo = modules[moduleName]
                        def servicePath = moduleInfo.path
                        def ecrRepo = moduleInfo.ecrRepo
                        def containerName = moduleInfo.containerName

                        stage("Build ${moduleName}") {
                            echo "Building module: ${moduleName}"

                            // Gradle ë¹Œë“œ
                            sh """
                                echo "Building ${servicePath}..."
                                chmod +x ./gradlew
                                ./gradlew :${servicePath}:build --no-daemon --stacktrace
                            """

                            // Docker ë¹Œë“œ ë° í‘¸ì‹œ
                            def imageTag = "${env.DOCKER_REGISTRY}/${ecrRepo}:${env.GIT_COMMIT_SHORT}"
                            def latestTag = "${env.DOCKER_REGISTRY}/${ecrRepo}:latest"

                            sh """
                                echo "Building Docker image: ${imageTag}"

                                # Docker ë¹Œë“œ ë° í‘¸ì‹œ
                                docker build --platform linux/amd64 \
                                    -t ${imageTag} \
                                    -t ${latestTag} \
                                    -f ./${servicePath}/Dockerfile .

                                docker push ${imageTag}
                                docker push ${latestTag}

                                echo "Successfully pushed: ${imageTag}"
                            """

                            // ë°°í¬ ë‹¨ê³„ (EKS - í•„ìš”ì‹œ ì£¼ì„ í•´ì œ)
                            /*
                            sh """
                                echo "Deploying to Kubernetes..."
                                aws eks update-kubeconfig --name Groom-EKS-Cluster --region ${env.AWS_REGION}
                                kubectl set image deployment/${containerName} \
                                    ${containerName}=${imageTag} -n default
                                kubectl rollout status deployment/${containerName} -n default
                            """
                            */

                            echo "Module ${moduleName} build completed successfully!"
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            // Docker ì´ë¯¸ì§€ ì •ë¦¬
            sh '''
                echo "Cleaning up Docker images..."
                docker system prune -f || true
                docker image prune -f || true
            '''
        }
        success {
            echo "ğŸ‰ Pipeline completed successfully!"
            script {
                if (env.CHANGED_MODULES) {
                    def modules = env.CHANGED_MODULES.split(',')
                    echo "âœ… Successfully built and deployed modules: ${modules.join(', ')}"

                    // ë¹Œë“œëœ ì´ë¯¸ì§€ ì •ë³´ ì¶œë ¥
                    modules.each { module ->
                        echo "ğŸ“¦ ${module}: ${env.DOCKER_REGISTRY}/${module}-service:${env.GIT_COMMIT_SHORT}"
                    }
                } else {
                    echo "â„¹ï¸ No changes detected, pipeline completed without build."
                }
            }
        }
        failure {
            echo "âŒ Pipeline failed!"
            echo "Please check the logs for detailed error information."
        }
    }

    triggers {
        // GitHub webhook íŠ¸ë¦¬ê±°
        githubPush()

        // ë˜ëŠ” SCM í´ë§ (5ë¶„ë§ˆë‹¤ ì²´í¬) - ì„ íƒì‚¬í•­
        // pollSCM('H/5 * * * *')
    }
}
