pipeline {
    agent any

    environment {
        AWS_REGION = 'ap-northeast-2'
        AWS_ACCOUNT_ID = '490913547024'
        DOCKER_REGISTRY = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

        // Git ì •ë³´
        GIT_COMMIT_SHORT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()

        // Jenkinsì—ì„œ AWS ìê²©ì¦ëª…ì„ ìœ„í•œ credential ID (Jenkinsì—ì„œ ì„¤ì • í•„ìš”)
        AWS_CREDENTIALS = 'aws-ecr-credentials'
    }

    parameters {
        choice(
            name: 'TARGET_BRANCH',
            choices: ['release/1.0.0', 'main', 'develop'],
            description: 'ë¹Œë“œí•  ë¸Œëœì¹˜ ì„ íƒ'
        )
        booleanParam(
            name: 'FORCE_BUILD_ALL',
            defaultValue: false,
            description: 'ëª¨ë“  ëª¨ë“ˆ ê°•ì œ ë¹Œë“œ ì—¬ë¶€'
        )
    }

    stages {
        stage('Check Tools') {
            steps {
                script {
                    echo "Checking available tools..."
                    
                    // ì‚¬ìš© ê°€ëŠ¥í•œ ë„êµ¬ë“¤ í™•ì¸
                    sh '''
                        echo "=== System Information ==="
                        whoami
                        pwd
                        echo "========================"
                        
                        echo "=== Available Tools ==="
                        echo "Java:"
                        java -version || echo "Java not found"
                        
                        echo "Docker:"
                        docker --version || echo "Docker not found"
                        
                        echo "AWS CLI:"
                        aws --version || echo "AWS CLI not found"
                        
                        echo "Git:"
                        git --version || echo "Git not found"
                        
                        echo "Curl:"
                        curl --version || echo "Curl not found"
                        echo "========================"
                    '''
                    
                    // Docker ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
                    def dockerAvailable = sh(script: 'command -v docker', returnStatus: true) == 0
                    env.DOCKER_AVAILABLE = dockerAvailable.toString()
                    
                    // AWS CLI ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
                    def awsAvailable = sh(script: 'command -v aws', returnStatus: true) == 0
                    env.AWS_AVAILABLE = awsAvailable.toString()
                    
                    echo "Docker available: ${dockerAvailable}"
                    echo "AWS CLI available: ${awsAvailable}"
                    
                    // í•„ìˆ˜ ë„êµ¬ê°€ ì—†ëŠ” ê²½ìš° ê²½ê³ 
                    if (!dockerAvailable) {
                        echo "âš ï¸ Docker is not available. Please install Docker or use Docker-in-Docker setup."
                    }
                    if (!awsAvailable) {
                        echo "âš ï¸ AWS CLI is not available. Please install AWS CLI or add it to the Jenkins image."
                    }
                }
            }
        }

        stage('Checkout') {
            steps {
                checkout scm
                script {
                    // ë³€ê²½ëœ íŒŒì¼ë“¤ í™•ì¸
                    def changedFiles = sh(
                        script: "git diff --name-only HEAD~1 HEAD || git ls-files",
                        returnStdout: true
                    ).trim().split('\n')

                    echo "Changed files: ${changedFiles}"
                    env.CHANGED_FILES = changedFiles.join(' ')
                }
            }
        }

        stage('Determine Changed Modules') {
            steps {
                script {
                    // ëª¨ë“ˆ ì •ë³´ ì •ì˜ (GitHub Actions workflow ê¸°ë°˜)
                    def modules = [
                        'auth': [
                            'path': 'msa-auth-service',
                            'ecrRepo': 'auth-service',
                            'containerName': 'auth-service'
                        ],
                        'common': [
                            'path': 'msa-common-service',
                            'ecrRepo': 'common-service',
                            'containerName': 'msa-common-service'
                        ],
                        'order': [
                            'path': 'msa-order-service',
                            'ecrRepo': 'order-service',
                            'containerName': 'msa-order-service'
                        ],
                        'payment': [
                            'path': 'msa-payment-service',
                            'ecrRepo': 'payment-service',
                            'containerName': 'msa-payment-service'
                        ],
                        'store': [
                            'path': 'msa-store-service',
                            'ecrRepo': 'store-service',
                            'containerName': 'msa-store-service'
                        ],
                        'user': [
                            'path': 'msa-user-service',
                            'ecrRepo': 'user-service',
                            'containerName': 'msa-user-service'
                        ]
                    ]

                    def changedModules = []
                    def changedFiles = env.CHANGED_FILES.split(' ')

                    if (params.FORCE_BUILD_ALL) {
                        changedModules = modules.keySet().toList()
                        echo "Force build all modules enabled"
                    } else {
                        modules.each { moduleName, moduleInfo ->
                            def hasChanges = changedFiles.any { file ->
                                file.startsWith(moduleInfo.path + '/')
                            }
                            if (hasChanges) {
                                changedModules.add(moduleName)
                            }
                        }
                    }

                    env.CHANGED_MODULES = changedModules.join(',')
                    env.MODULES_JSON = writeJSON returnText: true, json: modules

                    echo "Changed modules: ${changedModules}"

                    if (changedModules.isEmpty()) {
                        echo "No modules changed. Skipping build."
                        currentBuild.result = 'SUCCESS'
                        return
                    }
                }
            }
        }
        
        stage('Build Only (Without Docker)') {
            when {
                allOf {
                    not { environment name: 'CHANGED_MODULES', value: '' }
                    anyOf {
                        environment name: 'DOCKER_AVAILABLE', value: 'false'
                        environment name: 'AWS_AVAILABLE', value: 'false'
                    }
                }
            }
            steps {
                script {
                    def modules = readJSON text: env.MODULES_JSON
                    def changedModules = env.CHANGED_MODULES.split(',')
                    
                    echo "âš ï¸ Docker or AWS CLI not available. Building without Docker deployment."
                    
                    changedModules.each { moduleName ->
                        def moduleInfo = modules[moduleName]
                        def servicePath = moduleInfo.path
                        
                        stage("Build ${moduleName} (Gradle Only)") {
                            echo "Building module: ${moduleName} (Gradle only)"
                            
                            // Gradle ë¹Œë“œë§Œ ìˆ˜í–‰
                            sh """
                                echo "Building ${servicePath}..."
                                chmod +x ./gradlew || echo "gradlew not found, using system gradle"
                                ./gradlew :${servicePath}:build --no-daemon --stacktrace || gradle :${servicePath}:build --no-daemon --stacktrace
                            """
                            
                            echo "Module ${moduleName} Gradle build completed!"
                        }
                    }
                }
            }
        }
        
        stage('Install Docker & AWS CLI') {
            when {
                allOf {
                    not { environment name: 'CHANGED_MODULES', value: '' }
                    anyOf {
                        environment name: 'DOCKER_AVAILABLE', value: 'false'
                        environment name: 'AWS_AVAILABLE', value: 'false'
                    }
                }
            }
            steps {
                script {
                    echo "ğŸ”§ Installing missing tools..."
                    
                    // Docker ì„¤ì¹˜ (root ê¶Œí•œì´ ìˆëŠ” ê²½ìš°)
                    if (env.DOCKER_AVAILABLE == 'false') {
                        sh '''
                            # Docker ì„¤ì¹˜ ì‹œë„
                            apt-get update || echo "Cannot update packages"
                            apt-get install -y docker.io || echo "Cannot install docker.io"
                            
                            # Docker ì„œë¹„ìŠ¤ ì‹œì‘ ì‹œë„
                            service docker start || systemctl start docker || echo "Cannot start docker service"
                            
                            # Docker ë²„ì „ í™•ì¸
                            docker --version || echo "Docker still not available"
                        '''
                    }
                    
                    // AWS CLI ì„¤ì¹˜ (ë°”ì´ë„ˆë¦¬ ë‹¤ìš´ë¡œë“œ ë°©ì‹)
                    if (env.AWS_AVAILABLE == 'false') {
                        sh '''
                            # AWS CLI ë°”ì´ë„ˆë¦¬ ì§ì ‘ ë‹¤ìš´ë¡œë“œ ë° ì„¤ì¹˜
                            cd /tmp
                            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip" || echo "Failed to download AWS CLI"
                            unzip -o awscliv2.zip || echo "Failed to unzip AWS CLI"
                            
                            # ì„ì‹œ ë””ë ‰í† ë¦¬ì— ì„¤ì¹˜
                            mkdir -p /tmp/aws-cli
                            cp -r aws/* /tmp/aws-cli/ || echo "Failed to copy AWS CLI"
                            
                            # PATHì— ì¶”ê°€í•  ìˆ˜ ìˆë„ë¡ ì‹¬ë³¼ë¦­ ë§í¬ ìƒì„± ì‹œë„
                            ln -sf /tmp/aws-cli/dist/aws /usr/local/bin/aws || echo "Cannot create symlink, will use full path"
                            
                            # AWS CLI ë²„ì „ í™•ì¸
                            /tmp/aws-cli/dist/aws --version || aws --version || echo "AWS CLI still not available"
                            
                            # ì •ë¦¬
                            rm -rf awscliv2.zip aws/ || echo "Cleanup failed"
                        '''
                    }
                }
            }
        }
        
        stage('Build and Deploy Changed Modules') {
            when {
                not { environment name: 'CHANGED_MODULES', value: '' }
            }
            steps {
                script {
                    def modules = readJSON text: env.MODULES_JSON
                    def changedModules = env.CHANGED_MODULES.split(',')

                    // AWS ìê²©ì¦ëª… ë° ECR ë¡œê·¸ì¸
                    withCredentials([
                        [
                            $class: 'AmazonWebServicesCredentialsBinding',
                            credentialsId: env.AWS_CREDENTIALS,
                            accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                            secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                        ]
                    ]) {
                        sh """
                            # AWS CLI ê²½ë¡œ ì„¤ì •
                            export AWS_CLI_PATH=\$(which aws || echo "/tmp/aws-cli/dist/aws")
                            echo "Using AWS CLI at: \$AWS_CLI_PATH"
                            
                            \$AWS_CLI_PATH configure set aws_access_key_id \$AWS_ACCESS_KEY_ID
                            \$AWS_CLI_PATH configure set aws_secret_access_key \$AWS_SECRET_ACCESS_KEY
                            \$AWS_CLI_PATH configure set default.region ${env.AWS_REGION}
                            
                            # ECR ë¡œê·¸ì¸
                            \$AWS_CLI_PATH ecr get-login-password --region ${env.AWS_REGION} | \
                            docker login --username AWS --password-stdin ${env.DOCKER_REGISTRY}
                        """
                    }

                    // ê° ë³€ê²½ëœ ëª¨ë“ˆì— ëŒ€í•´ ìˆœì°¨ ì‹¤í–‰ (ë¦¬ì†ŒìŠ¤ ì ˆì•½)
                    changedModules.each { moduleName ->
                        def moduleInfo = modules[moduleName]
                        def servicePath = moduleInfo.path
                        def ecrRepo = moduleInfo.ecrRepo
                        def containerName = moduleInfo.containerName

                        stage("Build ${moduleName}") {
                            echo "Building module: ${moduleName}"

                            // Gradle ë¹Œë“œ
                            sh """
                                echo "Building ${servicePath}..."
                                chmod +x ./gradlew
                                ./gradlew :${servicePath}:build --no-daemon --stacktrace
                            """

                            // Docker ë¹Œë“œ ë° í‘¸ì‹œ
                            def imageTag = "${env.DOCKER_REGISTRY}/${ecrRepo}:${env.GIT_COMMIT_SHORT}"
                            def latestTag = "${env.DOCKER_REGISTRY}/${ecrRepo}:latest"

                            sh """
                                echo "Building Docker image: ${imageTag}"

                                # Docker ë¹Œë“œ ë° í‘¸ì‹œ
                                docker build --platform linux/amd64 \
                                    -t ${imageTag} \
                                    -t ${latestTag} \
                                    -f ./${servicePath}/Dockerfile .

                                docker push ${imageTag}
                                docker push ${latestTag}

                                echo "Successfully pushed: ${imageTag}"
                            """

                            // ë°°í¬ ë‹¨ê³„ (EKS - í•„ìš”ì‹œ ì£¼ì„ í•´ì œ)
                            /*
                            sh """
                                echo "Deploying to Kubernetes..."
                                aws eks update-kubeconfig --name Groom-EKS-Cluster --region ${env.AWS_REGION}
                                kubectl set image deployment/${containerName} \
                                    ${containerName}=${imageTag} -n default
                                kubectl rollout status deployment/${containerName} -n default
                            """
                            */

                            echo "Module ${moduleName} build completed successfully!"
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            // Docker ì´ë¯¸ì§€ ì •ë¦¬
            sh '''
                echo "Cleaning up Docker images..."
                docker system prune -f || true
                docker image prune -f || true
            '''
        }
        success {
            echo "ğŸ‰ Pipeline completed successfully!"
            script {
                if (env.CHANGED_MODULES) {
                    def modules = env.CHANGED_MODULES.split(',')
                    echo "âœ… Successfully built and deployed modules: ${modules.join(', ')}"

                    // ë¹Œë“œëœ ì´ë¯¸ì§€ ì •ë³´ ì¶œë ¥
                    modules.each { module ->
                        echo "ğŸ“¦ ${module}: ${env.DOCKER_REGISTRY}/${module}-service:${env.GIT_COMMIT_SHORT}"
                    }
                } else {
                    echo "â„¹ï¸ No changes detected, pipeline completed without build."
                }
            }
        }
        failure {
            echo "âŒ Pipeline failed!"
            echo "Please check the logs for detailed error information."
        }
    }

    triggers {
        // GitHub webhook íŠ¸ë¦¬ê±°
        githubPush()

        // ë˜ëŠ” SCM í´ë§ (5ë¶„ë§ˆë‹¤ ì²´í¬) - ì„ íƒì‚¬í•­
        // pollSCM('H/5 * * * *')
    }
}
