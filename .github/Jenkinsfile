pipeline {
    agent any

    environment {
        AWS_REGION = 'ap-northeast-2'
        AWS_ACCOUNT_ID = '490913547024'
        DOCKER_REGISTRY = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

        // Git ì •ë³´
        GIT_COMMIT_SHORT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()

        // Jenkinsì—ì„œ AWS ìê²©ì¦ëª…ì„ ìœ„í•œ credential ID (Jenkinsì—ì„œ ì„¤ì • í•„ìš”)
        AWS_CREDENTIALS = 'aws-ecr-credentials'
    }

    parameters {
        choice(
            name: 'TARGET_BRANCH',
            choices: ['release/1.0.0', 'main', 'develop'],
            description: 'ë¹Œë“œí•  ë¸Œëœì¹˜ ì„ íƒ'
        )
        booleanParam(
            name: 'FORCE_BUILD_ALL',
            defaultValue: false,
            description: 'ëª¨ë“  ëª¨ë“ˆ ê°•ì œ ë¹Œë“œ ì—¬ë¶€'
        )
    }

    stages {
        stage('Check Tools') {
            steps {
                script {
                    echo "Checking available tools..."

                    sh '''
                        echo "=== System Information ==="
                        whoami
                        pwd
                        echo "========================"

                        echo "Java:"
                        java -version || echo "Java not found"

                        echo "Docker:"
                        docker --version || echo "Docker not found"

                        echo "AWS CLI:"
                        aws --version || echo "AWS CLI not found"

                        echo "Git:"
                        git --version || echo "Git not found"

                        echo "Curl:"
                        curl --version || echo "Curl not found"
                        echo "========================"
                    '''

                    env.DOCKER_AVAILABLE = (sh(script: 'command -v docker', returnStatus: true) == 0).toString()
                    env.AWS_AVAILABLE = (sh(script: 'command -v aws', returnStatus: true) == 0).toString()

                    echo "Docker available: ${env.DOCKER_AVAILABLE}"
                    echo "AWS CLI available: ${env.AWS_AVAILABLE}"
                }
            }
        }

        stage('Install Docker & AWS CLI') {
            steps {
                script {
                    echo "ğŸ”§ Installing missing tools if necessary..."

                    // Docker ì„¤ì¹˜
                    sh '''
                        if ! command -v docker > /dev/null 2>&1; then
                            echo "Installing Docker..."
                            apt-get update -y
                            apt-get install -y docker.io
                            systemctl enable docker || true
                            systemctl start docker || true
                        else
                            echo "Docker already installed"
                        fi
                    '''

                    // AWS CLI ì„¤ì¹˜
                    sh '''
                        if ! command -v aws > /dev/null 2>&1; then
                            echo "Installing AWS CLI..."
                            cd /tmp
                            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                            unzip -o awscliv2.zip
                            ./aws/install
                            rm -rf awscliv2.zip aws/
                            export PATH=$PATH:/usr/local/bin
                        else
                            echo "AWS CLI already installed"
                        fi
                    '''
                }
            }
        }

        stage('Checkout') {
            steps {
                checkout scm
                script {
                    def changedFiles = sh(
                        script: "git diff --name-only HEAD~1 HEAD || git ls-files",
                        returnStdout: true
                    ).trim().split('\n')

                    echo "Changed files: ${changedFiles}"
                    env.CHANGED_FILES = changedFiles.join(' ')
                }
            }
        }

        stage('Determine Changed Modules') {
            steps {
                script {
                    def modules = [
                        'auth': ['path': 'msa-auth-service','ecrRepo': 'auth-service','containerName': 'auth-service'],
                        'common': ['path': 'msa-common-service','ecrRepo': 'common-service','containerName': 'msa-common-service'],
                        'order': ['path': 'msa-order-service','ecrRepo': 'order-service','containerName': 'msa-order-service'],
                        'payment': ['path': 'msa-payment-service','ecrRepo': 'payment-service','containerName': 'msa-payment-service'],
                        'store': ['path': 'msa-store-service','ecrRepo': 'store-service','containerName': 'msa-store-service'],
                        'user': ['path': 'msa-user-service','ecrRepo': 'user-service','containerName': 'msa-user-service']
                    ]

                    def changedModules = []
                    def changedFiles = env.CHANGED_FILES.split(' ')

                    if (params.FORCE_BUILD_ALL) {
                        changedModules = modules.keySet().toList()
                        echo "Force build all modules enabled"
                    } else {
                        modules.each { moduleName, moduleInfo ->
                            def hasChanges = changedFiles.any { file ->
                                file.startsWith(moduleInfo.path + '/')
                            }
                            if (hasChanges) {
                                changedModules.add(moduleName)
                            }
                        }
                    }

                    env.CHANGED_MODULES = changedModules.join(',')
                    env.MODULES_JSON = writeJSON returnText: true, json: modules

                    echo "Changed modules: ${changedModules}"

                    if (changedModules.isEmpty()) {
                        echo "No modules changed. Skipping build."
                        currentBuild.result = 'SUCCESS'
                        return
                    }
                }
            }
        }

        stage('Build and Deploy Changed Modules') {
            when {
                not { environment name: 'CHANGED_MODULES', value: '' }
            }
            steps {
                script {
                    def modules = readJSON text: env.MODULES_JSON
                    def changedModules = env.CHANGED_MODULES.split(',')

                    // AWS ìê²©ì¦ëª… ë° ECR ë¡œê·¸ì¸
                    withCredentials([
                        [
                            $class: 'AmazonWebServicesCredentialsBinding',
                            credentialsId: env.AWS_CREDENTIALS,
                            accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                            secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                        ]
                    ]) {
                        sh """
                            export AWS_CLI_PATH=\$(which aws || echo "/usr/local/bin/aws")
                            echo "Using AWS CLI at: \$AWS_CLI_PATH"

                            \$AWS_CLI_PATH configure set aws_access_key_id \$AWS_ACCESS_KEY_ID
                            \$AWS_CLI_PATH configure set aws_secret_access_key \$AWS_SECRET_ACCESS_KEY
                            \$AWS_CLI_PATH configure set default.region ${env.AWS_REGION}

                            \$AWS_CLI_PATH ecr get-login-password --region ${env.AWS_REGION} | \
                            docker login --username AWS --password-stdin ${env.DOCKER_REGISTRY}
                        """
                    }

                    changedModules.each { moduleName ->
                        def moduleInfo = modules[moduleName]
                        def servicePath = moduleInfo.path
                        def ecrRepo = moduleInfo.ecrRepo
                        def containerName = moduleInfo.containerName

                        stage("Build ${moduleName}") {
                            echo "Building module: ${moduleName}"

                            sh """
                                chmod +x ./gradlew
                                ./gradlew :${servicePath}:build --no-daemon --stacktrace
                            """

                            def imageTag = "${env.DOCKER_REGISTRY}/${ecrRepo}:${env.GIT_COMMIT_SHORT}"
                            def latestTag = "${env.DOCKER_REGISTRY}/${ecrRepo}:latest"

                            sh """
                                docker build --platform linux/amd64 \
                                    -t ${imageTag} \
                                    -t ${latestTag} \
                                    -f ./${servicePath}/Dockerfile .
                                docker push ${imageTag}
                                docker push ${latestTag}
                            """
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            sh '''
                echo "Cleaning up Docker images..."
                if command -v docker > /dev/null 2>&1; then
                    docker system prune -f
                    docker image prune -f
                else
                    echo "Docker not found, skipping cleanup"
                fi
            '''
        }
        success {
            echo "ğŸ‰ Pipeline completed successfully!"
        }
        failure {
            echo "âŒ Pipeline failed! Check logs."
        }
    }

    triggers {
        githubPush()
    }
}